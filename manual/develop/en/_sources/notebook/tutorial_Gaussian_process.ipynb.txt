{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "# Gaussian process\n",
    "\n",
    "PHYSBO performs Bayesian optimization while running Gaussian process regression.\n",
    "\n",
    "Therefore, it is possible to run Gaussian process regression given training data, and to predict test data using the trained model.\n",
    "\n",
    "In this section, the procedure is introduced.\n",
    "\n",
    "\n",
    "## Preparation of search candidate data\n",
    "\n",
    "In this tutorial, the problem of finding a stable interface structure for Cu is used as an example. The values that have already been evaluated are used, although the evaluation of the objective function, i.e., the structural relaxation calculation, actually takes on the order of several hours per calculation. For more information on the problem setup, please refer to the following references\n",
    "\n",
    "- S. Kiyohara, H. Oda, K. Tsuda and T. Mizoguchi, “Acceleration of stable interface structure searching using a kriging approach”, Jpn. J. Appl. Phys. 55, 045502 (2016).\n",
    "\n",
    "\n",
    "Save the dataset file [s5-210.csv](https://raw.githubusercontent.com/issp-center-dev/PHYSBO/master/examples/grain_bound/data/s5-210.csv) and load dataset from this file as the following:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:11:41.987250Z",
     "start_time": "2020-12-04T06:11:41.537168Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import physbo\n",
    "\n",
    "def load_data():\n",
    "    A =  np.asarray(np.loadtxt('s5-210.csv',skiprows=1, delimiter=',') )\n",
    "    X = A[:,0:3]\n",
    "    t  = -A[:,3]\n",
    "    return X, t\n",
    "\n",
    "X, t = load_data()\n",
    "X = physbo.misc.centering( X )\n",
    "\n",
    "np.random.seed(12345)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "## Defining training data\n",
    "\n",
    "A randomly selected 10% of the target data will be used as training data, and another randomly selected 10% will be used as test data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:11:51.077070Z",
     "start_time": "2020-12-04T06:11:51.072211Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Ntrain = 1798\n",
      "Ntest = 1798\n"
     ]
    }
   ],
   "source": [
    "N = len(t)\n",
    "Ntrain = int(N*0.1)\n",
    "Ntest = min(int(N*0.1), N-Ntrain)\n",
    "\n",
    "id_all   = np.random.choice(N, N, replace=False)\n",
    "id_train  = id_all[0:Ntrain]\n",
    "id_test = id_all[Ntrain:Ntrain+Ntest]\n",
    "\n",
    "X_train = X[id_train]\n",
    "X_test = X[id_test]\n",
    "\n",
    "t_train = t[id_train]\n",
    "t_test = t[id_test]\n",
    "\n",
    "print(\"Ntrain =\", Ntrain)\n",
    "print(\"Ntest =\", Ntest)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "## Learning and Prediction of Gaussian Processes\n",
    "\n",
    "The following process is used to learn the Gaussian process and predict the test data.\n",
    "\n",
    "1. Generate a model of the Gaussian process\n",
    "\n",
    "2. The model is trained using X_train (parameters of the training data) and t_train (objective function value of the training data).\n",
    "\n",
    "3. Run predictions on the test data (X_test) using the trained model.\n",
    "\n",
    "Definition of covariance (Gaussian)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:11:55.403677Z",
     "start_time": "2020-12-04T06:11:55.399915Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "cov = physbo.gp.cov.Gauss( X_train.shape[1],ard = False )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Definition of mean value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:11:56.279543Z",
     "start_time": "2020-12-04T06:11:56.277082Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "mean = physbo.gp.mean.Const()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Definition of likelihood function (Gaussian)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:11:57.077507Z",
     "start_time": "2020-12-04T06:11:57.075581Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "lik = physbo.gp.lik.Gauss()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Generation of a Gaussian Process Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:11:57.832602Z",
     "start_time": "2020-12-04T06:11:57.828902Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "gp = physbo.gp.Model(lik=lik,mean=mean,cov=cov)\n",
    "config = physbo.misc.SetConfig()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Learning a Gaussian process model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.218792Z",
     "start_time": "2020-12-04T06:11:58.261609Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Start the initial hyper parameter searching ...\n",
      "Done\n",
      "\n",
      "Start the hyper parameter learning ...\n",
      "0 -th epoch marginal likelihood 16183.32665836015\n",
      "50 -th epoch marginal likelihood 3766.7342499250817\n",
      "100 -th epoch marginal likelihood 1450.3500890284013\n",
      "150 -th epoch marginal likelihood 127.98987541458473\n",
      "200 -th epoch marginal likelihood -665.7141798300413\n",
      "250 -th epoch marginal likelihood -1132.4472253356093\n",
      "300 -th epoch marginal likelihood -1340.554624477777\n",
      "350 -th epoch marginal likelihood -1438.3983041110043\n",
      "400 -th epoch marginal likelihood -1464.5751633473951\n",
      "450 -th epoch marginal likelihood -1478.481755278168\n",
      "500 -th epoch marginal likelihood -1485.7013807794128\n",
      "Done\n",
      "\n"
     ]
    }
   ],
   "source": [
    "gp.fit(X_train, t_train, config)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Output the parameters in the learned Gaussian process."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.227479Z",
     "start_time": "2020-12-04T06:12:58.221821Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      "likelihood parameter =   [-2.44630277]\n",
      "mean parameter in GP prior:  [-1.06536273]\n",
      "covariance parameter in GP prior:  [-0.64183368 -2.49190006]\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "gp.print_params()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Calculating the mean (predicted value) and variance of the test data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.605713Z",
     "start_time": "2020-12-04T06:12:58.244883Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "gp.prepare(X_train, t_train)\n",
    "fmean = gp.get_post_fmean(X_train, X_test)\n",
    "fcov = gp.get_post_fcov(X_train, X_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Results of prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.618218Z",
     "start_time": "2020-12-04T06:12:58.607794Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-1.04749842, -0.99756623, -1.09935748, ..., -1.07561436,\n",
       "       -1.07684287, -1.10315271])"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fmean"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Results of covariance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.628483Z",
     "start_time": "2020-12-04T06:12:58.622345Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.0006267 , 0.00053271, 0.00095938, ..., 0.00067901, 0.00066522,\n",
       "       0.00055919])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fcov"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Output mean square error of prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.636081Z",
     "start_time": "2020-12-04T06:12:58.631461Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.006925305425496949"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.mean((fmean-t_test)**2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A simple metric to investigate how important each feature is in the obtained regression model is permutation importance (PI).\n",
    "In PHYSBO, this can be calculated using the get_permutation_importance function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "pi_mean, pi_std = gp.get_permutation_importance(X_train, t_train, n_perm=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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CZVa73HHHbfVz/uXf/mXsM8++2yyfMWKFeGoo44KXWnOnDlhwIABoZINHz48XHfddeUuA6AiNZS7AIBqceSRR4bZs2eHdevWhXvvvTecc845oWfPnuHSSy/d6m1t2LAhhZT6+uq4vrPjjjuG7mz9+vUpUALw7qrjXzSACtDY2JhOsIcNGxY+//nPh/Hjx4ef/vSn6bEYNi666KKw8847h759+4Zx48aFX/ziF5tcjY/r77nnnmlbzz33XLoC/q//+q/h1FNPDf369Uvbjuv89a9/Dccee2xatvfee4ff/e5379mqEK+ix22VHv+3f/u3MG/evJZWllItl1xySdhtt91Cnz59woc+9KFw+eWXh7fffrulxiuuuCIsWbKk5Xlx2ea6Qj3xxBPh4x//eNhmm23C9ttvH84888ywevXqTVpMvva1r4WddtoprRODWOm12qO0nzfffHPYZZdd0ntx9tlnp1B2zTXXpM9i0KBB4aqrrmrzvFjrDTfckFpYYn1xP++8884267S3/rjtIUOGhA9/+MPhsMMOC88++2y44IILWt6f6NVXXw2f+cxn0mcf39ePfvSj4bbbbmvzevG55513XvjiF78YBg4cmGqP+9fa66+/Hs4666wwePDg0Lt377DXXnuFu+++u+XxX/3qV+GQQw5JNQ8dOjRtb82aNe1+PwG6mmAB0EHxBC9eyY7OPffcsGDBgnD77beHP/zhD+H4449PLRx//vOfW9b/29/+Fr761a+Gm266Kfzxj39MJ8XRzJkzw0EHHRQWLVoUjj766HDKKaekoHHyySeH3//+92HXXXdN94uiaFddMeCccMIJ6fVjF6Z4O/DAA9Nj2267bQoLf/rTn8I3vvGN8N3vfje9fnTiiSeGCy+8MHzkIx9peV5ctrF4MjthwoSw3Xbbhd/+9rfhRz/6UfjZz36W3oPWHnroofCXv/wl/YxBJ75uKai0V3z+fffdF+6///50sv69730vvUcvvPBC+OUvf5nez8suuyw89thjbZ4XA9M//MM/pJB00kknhU9/+tPhqaee2qr6H3zwwbB06dIwf/78dIL/4x//OHzwgx9MXeBK70+0du3aMHbs2HDPPfeEJ598MoWU+Bk+/vjjbbYX34MYOmOtMRjF7cRtR83NzSkI/frXvw4/+MEP0uczffr00KNHj5b3IX6ecZ/i8TV37twUNDauGaCsCgC2aOLEicWxxx6bfm9ubi7mz59fNDY2FhdddFHx7LPPFj169CiWL1/e5jlHHHFEcemll6bfZ8+eHVNBsXjx4jbrDBs2rDj55JNb7q9YsSKtd/nll7csW7BgQVoWH4umTp1ajB49us12Zs6cmba1uXrfy4wZM4qxY8e23N/ctqP4+nfddVf6/cYbbyy22267YvXq1S2P33PPPUV9fX2xcuXKlteP9bzzzjst6xx//PHFiSee+K61xPeof//+bWrp06dPsWrVqpZlEyZMKIYPH15s2LChZdmHP/zhYtq0aW1qnTRpUpttjxs3rvj85z+/VfUPHjy4WLduXZvtxH2K7/WWHH300cWFF17Ycv/QQw8tDj744Dbr7LfffsUll1ySfn/ggQfS6y9dunSz2/vc5z5XnHnmmW2WPfLII+k5b7311hbrAXg/GGMB0E7xqnXsjhO788QrzJ/97GdTd5bYzSh2z4ldjFqL3aNiN5uS2Ec/dmvaWOtlsRtMFLvTbLzs5Zdfzh7rEK90f/Ob30xXwGPXnzj4vKmpaau2Ea/8jx49Ol19L4ktLvE9iVf4S/XGlo/SFfcodomKXZC2RuzeFVtZSuK24zZbj02Jy+J709oBBxywyf3FixdvVf3xM2jPuIr42V999dXhjjvuCMuXL0+tWPGzj92iWtv4s4/vR6nuWFtsDdn4GCqJLS+xpeLWW29tWRYzVKx52bJlYY899thinQBdTbAAaKfDDz889d2PJ5ux331Dw///CY0n6PFkd+HChW1OpKMYRFp3nSr1y28tDgAvKT2+uWXxJDKKJ9Ubd4tqz9iF2FUrdguK4yhiV6D+/funrlvXXntt6Aqt96G0H6V9yNlGZ2y3PVoHj/cyY8aM1K0sjnOJYSQ+7/zzz2/pJlfyXnXHY+O9xGMsjr+I4yo2FsefAFQCwQKgneIJY5xmdmNjxoxJV63j1ec4uLar7bDDDmHlypUpXJRCR+lqfEkMP7Gm1n7zm9+kweFf/vKXW5bFwchbet7G4tXxOFYijlUonXzHsQEx8MRBzpXg0UcfTeNSWt+Pn1Nu/Zt7f+Jz40D7OCYmimHhv/7rv9Ig/faKrRlx3Eh83uZaLf7u7/4ujbvY3PEHUCkM3gbIFE8EY0tAPJGNA3xj15Q4cHfatGlpQG9nizMMxVmj4gDg2KVp1qxZaYDzxl2IYteZ2LXnlVdeSS0ao0aNSjNRxVaK+LzYJequu+7a5Hmx/hhU4vNil56NxX2NsxZNnDgxDVaOg7O/8IUvpAHLpW5E5RYHZMfZpOKJ+tSpU9PnURronFN/fH8efvjh1OUpvj9RfF/jIOwY3GI3q9iy8NJLL21VvYceemj42Mc+lgZnx23Fz6A0aL00m1fcftyH+NnESQHirF8GbwOVRLAA6ATx+y1isIizKsWr3nGq0jjjUFd0U4lX3L/97W+nQBHHCsST5jgTVGtnnHFGqmPfffdNLRzxqvoxxxyTpkqNJ6NxGtd4ohpnT2otntjG2Ydit6/4vI2nTY3i2IEHHnggvPbaa2G//fYLn/rUp8IRRxwRvvWtb4VKEbt7xQAVWwJuueWWtB+lFoSc+uNMTs8880yaqSu+P1GclSq2KMTuZTH0xXEwHflywn//939P9cSpa2OtcWraUutI3I84C1YMSrFVLLa+TJkyJXXJA6gUdXEEd7mLAIDOEruHxZaYjpzcA9BxWiwAAIBsggUAAJDNrFAA1BQ9fAHKQ4sFAACQTbAAAACyCRYAAEA2wQIAAMgmWAAAANkECwAAIJtgAQAAZBMsAACAbIIFAAAQcv0fw3RYAVV/epsAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 800x500 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "features = list(range(len(pi_mean)))\n",
    "\n",
    "plt.figure(figsize=(8, 5))\n",
    "plt.barh(\n",
    "    features,\n",
    "    pi_mean,\n",
    "    xerr=pi_std,\n",
    ")\n",
    "plt.gca().invert_yaxis()\n",
    "plt.yticks(features)\n",
    "plt.xlabel(\"Permutation Importance\")\n",
    "plt.ylabel(\"Features\")\n",
    "plt.tight_layout()\n",
    "# print(\"save permutation_importance.pdf\")\n",
    "# plt.savefig(\"permutation_importance.pdf\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this graph, the bar chart represents the mean value of the permutation importance (PI), while the line segments indicate the standard deviation. From this, we can interpret that features 1 and 2 appear to be more important compared to feature 0.\n",
    "\n",
    "Not only gp.model, but policy also has the get_permutation_importance function.\n",
    "The usage is policy.get_permutation_importance(n_perm).\n",
    "In the case of policy, PI is calculated based on the stored training data, so unlike model, there is no need to pass the data again."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "##  Prediction by trained models\n",
    "\n",
    "Read the parameters of the trained model as gp_params and make predictions using them.\n",
    "\n",
    "By storing gp_params and training data (X_train, t_train), prediction by the trained model is possible."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Prepare the learned parameters (must be done immediately after learning)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.645968Z",
     "start_time": "2020-12-04T06:12:58.639012Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-2.44630277, -1.06536273, -0.64183368, -2.49190006])"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Prepare the learned parameters as a 1D array\n",
    "gp_params =  np.append(np.append(gp.lik.params, gp.prior.mean.params), gp.prior.cov.params)\n",
    "\n",
    "gp_params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Prepare a model similar to the one used for training as gp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:58.666019Z",
     "start_time": "2020-12-04T06:12:58.653259Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "#Definition of covariance (Gaussian)\n",
    "cov = physbo.gp.cov.Gauss( X_train.shape[1],ard = False )\n",
    "\n",
    "#Definition of mean value\n",
    "mean = physbo.gp.mean.Const()\n",
    "\n",
    "#Definition of likelihood function (Gaussian)\n",
    "lik = physbo.gp.lik.Gauss()\n",
    "\n",
    "#Generation of a Gaussian Process Model\n",
    "gp = physbo.gp.Model(lik=lik,mean=mean,cov=cov)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Prepare a model similar to the one used for training as gp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:59.016429Z",
     "start_time": "2020-12-04T06:12:58.673034Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "#Input learned parameters into the Gaussian process.\n",
    "gp.set_params(gp_params)\n",
    "\n",
    "\n",
    "#Calculate the mean (predicted value) and variance of the test data\n",
    "gp.prepare(X_train, t_train)\n",
    "fmean = gp.get_post_fmean(X_train, X_test)\n",
    "fcov = gp.get_post_fcov(X_train, X_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Results of prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:59.020795Z",
     "start_time": "2020-12-04T06:12:59.017606Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-1.04749842, -0.99756623, -1.09935748, ..., -1.07561436,\n",
       "       -1.07684287, -1.10315271])"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fmean"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Results of covariance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:59.026523Z",
     "start_time": "2020-12-04T06:12:59.023035Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.0006267 , 0.00053271, 0.00095938, ..., 0.00067901, 0.00066522,\n",
       "       0.00055919])"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fcov"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Output mean square error of prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:12:59.033497Z",
     "start_time": "2020-12-04T06:12:59.027871Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.006925305425496949"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.mean((fmean-t_test)**2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "source": [
    "Note: In the example above, we used the same pre-registered X to make predictions.\n",
    "If you want to make predictions for parameters X_new that is not included in X using the trained model,\n",
    "you first obtain the mean (X_{mean}) and standard deviation (X_{std}) of the data X and\n",
    "then normalize X_{new} by (X_{new} - X_{mean}) / X_{std}.\n",
    "Also, the data format for X is ndarray format.\n",
    "Therefore, if X_{new} is a single data, it must be transformed to ndarray format.\n",
    "For example, if X_{new} is a real number, you should replace X_new as\n",
    "X_new = np.array(X_new).reshape(1)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
